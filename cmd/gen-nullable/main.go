package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"
)

const schemaDir = "graph/schema"
const outputFile = "graph/model/nullable_gen.go"

var nullableTypes = map[string]struct {
	GoType   string
	ValueFmt string
}{
	"NullableString": {"NullableString", "protoreflect.ValueOfString(*input.%s.Value)"},
	"NullableInt":    {"NullableInt", "protoreflect.ValueOfInt64(int64(*input.%s.Value))"},
	"NullableFloat":  {"NullableFloat", "protoreflect.ValueOfFloat64(*input.%s.Value)"},
	"NullableBool":   {"NullableBool", "protoreflect.ValueOfBool(*input.%s.Value)"},
}

type inputInfo struct {
	Name   string
	Fields []fieldInfo
}

type fieldInfo struct {
	GoName    string
	ProtoName string
	Type      string
}

func main() {
	inputs, err := parseSchemas(schemaDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "parse error: %v\n", err)
		os.Exit(1)
	}

	if len(inputs) == 0 {
		os.Remove(outputFile)
		return
	}

	if err := generate(inputs); err != nil {
		fmt.Fprintf(os.Stderr, "generate error: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("generated %s (%d inputs)\n", outputFile, len(inputs))
}

func parseSchemas(dir string) ([]inputInfo, error) {
	files, err := filepath.Glob(filepath.Join(dir, "*.graphqls"))
	if err != nil {
		return nil, err
	}

	var inputs []inputInfo
	for _, f := range files {
		data, err := os.ReadFile(f)
		if err != nil {
			return nil, err
		}
		inputs = append(inputs, extractInputs(string(data))...)
	}
	return inputs, nil
}

var inputBlockRe = regexp.MustCompile(`(?m)^input\s+(\w+)\s*\{([^}]+)\}`)
var fieldRe = regexp.MustCompile(`^\s*(\w+)\s*:\s*(\w+)`)

func extractInputs(schema string) []inputInfo {
	var inputs []inputInfo

	for _, match := range inputBlockRe.FindAllStringSubmatch(schema, -1) {
		name := match[1]
		body := match[2]

		var fields []fieldInfo
		for line := range strings.SplitSeq(body, "\n") {
			fm := fieldRe.FindStringSubmatch(line)
			if fm == nil {
				continue
			}
			fieldName, typeName := fm[1], fm[2]
			if _, ok := nullableTypes[typeName]; !ok {
				continue
			}
			fields = append(fields, fieldInfo{
				GoName:    upperFirst(fieldName),
				ProtoName: camelToSnake(fieldName),
				Type:      typeName,
			})
		}

		if len(fields) > 0 {
			inputs = append(inputs, inputInfo{Name: name, Fields: fields})
		}
	}

	return inputs
}

func generate(inputs []inputInfo) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by gen-nullable; DO NOT EDIT.\n\n")
	buf.WriteString("package model\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"google.golang.org/protobuf/proto\"\n")
	buf.WriteString("\t\"google.golang.org/protobuf/reflect/protoreflect\"\n")
	buf.WriteString("\t\"google.golang.org/protobuf/types/known/fieldmaskpb\"\n")
	buf.WriteString(")\n\n")

	for _, input := range inputs {
		fmt.Fprintf(&buf, "type %s struct {\n", input.Name)
		for _, f := range input.Fields {
			goType := nullableTypes[f.Type].GoType
			fmt.Fprintf(&buf, "\t%s %s `json:\"%s\"`\n", f.GoName, goType, f.ProtoName)
		}
		buf.WriteString("}\n\n")

		fmt.Fprintf(&buf, "func Apply%s(input %s, msg proto.Message) *fieldmaskpb.FieldMask {\n", input.Name, input.Name)
		buf.WriteString("\tvar paths []string\n")
		buf.WriteString("\tmsgReflect := msg.ProtoReflect()\n\n")

		for _, f := range input.Fields {
			valueFmt := nullableTypes[f.Type].ValueFmt

			fmt.Fprintf(&buf, "\tif input.%s.Set {\n", f.GoName)
			fmt.Fprintf(&buf, "\t\tif input.%s.Value != nil {\n", f.GoName)
			fmt.Fprintf(&buf, "\t\t\tif fd := msgReflect.Descriptor().Fields().ByName(\"%s\"); fd != nil {\n", f.ProtoName)
			fmt.Fprintf(&buf, "\t\t\t\tmsgReflect.Set(fd, "+valueFmt+")\n", f.GoName)
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t}\n")
			fmt.Fprintf(&buf, "\t\tpaths = append(paths, \"%s\")\n", f.ProtoName)
			buf.WriteString("\t}\n\n")
		}

		buf.WriteString("\treturn &fieldmaskpb.FieldMask{Paths: paths}\n")
		buf.WriteString("}\n\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format: %w (raw output:\n%s)", err, buf.String())
	}

	return os.WriteFile(outputFile, formatted, 0644)
}

func upperFirst(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func camelToSnake(s string) string {
	var b strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				b.WriteByte('_')
			}
			b.WriteRune(unicode.ToLower(r))
		} else {
			b.WriteRune(r)
		}
	}
	return b.String()
}
